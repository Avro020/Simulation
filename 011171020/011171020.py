# -*- coding: utf-8 -*-
"""ssq.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bTTAjDOpAQW3ZApvxh70rsq7VFpCrSy8
"""

import numpy as np

class SSQ:
  def __init__(self,option):   #Initialization
    #self.interarrivals= [0.4,1.2,0.5,1.7,0.2,1.6,0.2,1.4,1.9]  #exponential distribution 
    #self.service_times= [2.0,0.7,0.2,1.1,3.7,0.6,0.7,0.9,1.2]  #exponential distribution
    np.random.seed(0)
    
    self.interarrivals= list(np.random.exponential(0.5,100))
    self.service_times= list(np.random.exponential(1.3,100))

    #self.interarrivals= [0.397937254081555, 0.6279653814829189, 0.4616115729020344, 0.39360057615863536, 0.2755242455477496, 0.5190796474718047, 0.2877595995843199, 1.1117622065163284, 1.657456091026907, 0.24180105045112665, 0.7844480699845842, 0.3763370547682942, 0.41971642336941145, 1.2991270769627203, 0.03684267745642394, 0.04558051455950024, 0.010212793342112475, 0.8937438398074441, 0.7528921159326077, 1.0201571404727754]
    #self.service_times= [4.998788389616904, 2.08681142663519, 0.8046082961968591, 1.9714967699441972, 0.16363673537970563, 1.3278614523096948, 0.20114858754593876, 3.762746584598984, 0.9591754618043763, 0.6962354337909832, 0.3994644590175899, 1.9347312903447555, 0.7918071411940105, 1.0924351189278956, 0.02465914316109906, 1.2497952079533172, 1.2310956811969116, 1.2474123645480066, 3.7412896023633304, 1.4886806462454891]
    self.clock= 0.0
    
    self.next_arrival=self.interarrivals.pop(0)
    self.next_departure1= float('inf')
    self.next_departure2=float('inf')
    
    self.num_in_queue= 0
    self.times_of_arrivalqueue= []         #store times of arrivals who are waiting in the queue
    self.service_times_in_queue= []   #store service times of waiting customers in the queue
    
    self.total_delay=0.0
    self.num_of_delays= 0.0
    self.area_under_q= 0.0
    self.area_under_b1= 0.0
    self.area_under_b2= 0.0
    
    self.server1_status= 0        #0 for IDLE , 1 for BUSY
    self.server2_status=0
    self.last_event_time=0.0     #we will need to store last event clock time 
 
  def start(self):
    while self.num_of_delays<6:
      self.timing()
    self.report()
    
  
  def timing(self):
    self.clock= min(self.next_arrival,self.next_departure1,self.next_departure2)  #First set clock to minimum time of next event
    self.update_register()
    if self.next_arrival<= self.next_departure1 and self.next_arrival<=self.next_departure2:
      self.arrival()
      self.last_event_time=self.clock
      print("Arrival at Clock:" +str(self.clock))

    elif self.next_departure1<=self.next_arrival and self.next_departure1<=self.next_departure2:
      self.departure1()
      self.last_event_time=self.clock
      print("Departure at server1 at "+str(self.clock))
    
    else:
      self.departure2()
      self.last_event_time=self.clock
      print("Departure at server2 at "+str(self.clock))

    print("Server1 Status: "+str(self.server1_status))
    print("Server2 Status: "+str(self.server2_status))
    print("Times of arrivals in Queue: "+ str(self.times_of_arrivalqueue))
    print("Service times in Queue: "+str(self.service_times_in_queue))
    
    print("Next Arrival Time: "+str(self.next_arrival))
    print("Next Departure of server1 Time: "+str(self.next_departure1))
    print("Next Departure of server2 Time: "+str(self.next_departure2))
    print("Total Delay: " +str(self.total_delay))
    print("Number of Customer delayed: ", self.num_of_delays)
    print(" ")

  def arrival(self):
    #Schedule next arrival , new_arrival = previous_arrival + inter_arrival time of next customer
    self.next_arrival= self.next_arrival+ self.interarrivals.pop(0)  
    
    if self.server1_status==0:   #server is idle
      self.server1_status= 1    #make server BUSY
      delay=0.0            #so delay is zero
      self.total_delay += delay  
      self.num_of_delays +=1   #increase the number of customers delayed

      #schedule next departure, pop the first element of service_times list to get service time of this customer
      self.next_departure1 = self.clock+ self.service_times.pop(0) 
    elif self.server2_status==0:
      self.server2_status= 1    #make server BUSY
      delay=0.0            #so delay is zero
      self.total_delay += delay  
      self.num_of_delays +=1   #increase the number of customers delayed
      #schedule next departure, pop the first element of service_times list to get service time of this customer
      self.next_departure2 = self.clock+ self.service_times.pop(0)
      
  
    else:     #Server is BUSY
      #increase queue length, this customer will have to wait in the queue
      self.num_in_queue+=1

      #store the arrival time and service time of this customer in seperate lists
      self.times_of_arrivalqueue.append(self.clock) 
      self.service_times_in_queue.append(self.service_times.pop(0)) 

  def departure1(self): ##depart from server-1
    #check number of customers in the queue
    if self.num_in_queue==0:  #if no customer in the queue
      #make server IDLE 
      self.server1_status= 0
      #schedule next departure= infinity
      self.next_departure1= float('infinity')
    else: 
      #if queue not empty, pop one customer, decrease queue length
      self.num_in_queue-=1
      self.num_of_delays+=1
      #AS FIFO, pop first arrival and service time from the queue. IF LIFO we have to pop last arrival and service time
      #For SJF, finf the index of minimum service time from  service_times_in_queue list.
      #Then pop the arrival of that index from times_of_arrivalqueue for delay count and others.  
      if option==1:
        arrival= self.times_of_arrivalqueue.pop(0)
        delay= self.clock- arrival
        self.total_delay+=delay
        self.next_departure1= self.clock+ self.service_times_in_queue.pop(0)
      if option==2:
        arrival= self.times_of_arrivalqueue.pop(-1)
        delay= self.clock- arrival
        self.total_delay+=delay
        self.next_departure1= self.clock+ self.service_times_in_queue.pop(-1) 
      elif option==3:
        minpos=self.service_times_in_queue.index(min(self.service_times_in_queue))
        arrival= self.times_of_arrivalqueue.pop(minpos)
        delay= self.clock- arrival
        self.total_delay+=delay
        self.next_departure1= self.clock+ self.service_times_in_queue.pop(minpos) 
      


  def departure2(self): ##depart from server-2
    #check number of customers in the queue
    if self.num_in_queue==0:  #if no customer in the queue
      #make server IDLE 
      self.server2_status= 0
      #schedule next departure= infinity
      self.next_departure2= float('infinity')
    
    else: 
      #if queue not empty, pop one customer, decrease queue length
      self.num_in_queue-=1
      self.num_of_delays+=1
      #AS FIFO, pop first arrival and service time from the queue. IF LIFO we have to pop last arrival and service time
      #For SJF, finf the index of minimum service time from  service_times_in_queue list.
      #Then pop the arrival of that index from times_of_arrivalqueue for delay count and others.  
    
      if option==1:
        arrival= self.times_of_arrivalqueue.pop(0)
        delay= self.clock- arrival
        self.total_delay+=delay
        self.next_departure2= self.clock+ self.service_times_in_queue.pop(0)
      elif option==2:
        arrival= self.times_of_arrivalqueue.pop(-1)
        delay= self.clock- arrival
        self.total_delay+=delay
        self.next_departure2= self.clock+ self.service_times_in_queue.pop(-1)
      elif option==3:
        minpos=self.service_times_in_queue.index(min(self.service_times_in_queue))
        arrival= self.times_of_arrivalqueue.pop(minpos)
        delay= self.clock- arrival
        self.total_delay+=delay
        self.next_departure2= self.clock+ self.service_times_in_queue.pop(minpos)      
 
     


    

  def update_register(self):
    time_difference= self.clock - self.last_event_time
    self.area_under_q+= time_difference*self.num_in_queue

    self.area_under_b1+= time_difference*self.server1_status
    self.area_under_b2+= time_difference*self.server2_status
    self.last_event_time=self.clock
    print("Area under q(t): ",self.area_under_q)
    print("Area under b(t) for server1: ",self.area_under_b1)
    print("Area under b(t) for server2: ",self.area_under_b2)
  
  def report(self):
    print("Average dealy: ", self.total_delay/6)
    print("Expected Number of customer in queue: ",self.area_under_q/self.last_event_time )
    print("Expected Utilization for server1: ",self.area_under_b1/self.last_event_time )
    print("Expected Utilization for server2: ",self.area_under_b2/self.last_event_time )

print("Press 1 for FIFO")
print("press 2 for LIFO")
print("Press 3 for SJF")
option=int(input())

s = SSQ(option)
s.start()